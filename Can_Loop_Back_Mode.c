/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include "stm32f4xx.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif
/*
#define RCC_BASE_ADDR 0x40023800UL
#define RCC_APB1ENR_ADDR 0x40023840UL
#define RCC_AHB1ENR_ADDR 0x40023830UL

#define GPIOB_BASE_ADDR 0X40020400UL
#define GPIOB_MODER_ADDR 0x40020400UL
#define GPIOB_AFRH_ADDR 0x40020424UL

#define CAN1_BASE_ADDR 0x40006400UL
#define CAN1_MCR_ADDR 0x40006400UL
#define CAN1_MSR_ADDR 0x40006404UL
#define CAN1_BTR_ADDR 0x4000641CUL
#define CAN1_TI0R_ADDR 0x40006180UL
#define CAN1_TDT0R_ADDR 0x40006184UL
#define CAN1_TDL0R_ADDR 0x40006188UL
#define CAN1_TDH0R_ADDR 0x4000618CUL
#define CAN1_RI0R_ADDR 0x400061B0UL
#define CAN1_RDT0R_ADDR 0x400061B4UL
#define CAN1_RL0R_ADDR 0x400061B8UL
#define CAN1_RH0R_ADDR 0x400061BCUL
*/
#include "stm32f4xx.h"
void GPIO_Init(void);
void CAN1_Init(void);
void CAN1_Tx(uint8_t tr);
uint8_t CAN1_Rx(void);
uint8_t key = 'M';
uint8_t rec = 0;

void GPIO_Init(){
	 RCC->AHB1ENR |= (1<<1);//GPIOB CLOCK ENABLE

	 // Set PB8, PB9 to Alternate Function
	 GPIOB->MODER &= 0xFFF0FFFF;
	 GPIOB->MODER |= 0x000A0000;
	//Setting CAN1_RX and CAN1_TX in PB8 and PB9
	 GPIOB->AFR[1] |= (0x9 << 0);
	 GPIOB->AFR[1] |= (0x9 << 4);

}
void CAN1_Init(){

	RCC->APB1ENR |= (1<<25);//CAN1 CLOCK ENABLE

	CAN1->MCR |= (1<<0);
	while (!(CAN1->MSR & (1 << 0)))
	{}
	CAN1->BTR |= (1 << 30); //Enable loop back mode
	// Setting the Re-synchronization jump width to 1
	CAN1->BTR &= ~(3 << 24); // Clear bits 25 and 24
	CAN1->BTR |= (1 << 24);  // Set CAN_BTR_SJW using left shift
	// Setting the number of time quanta for Time segment 2 (TS2 = 4-1)
	CAN1->BTR &= ~(7 << 20);  // Clear bits 22, 21, and 20
	CAN1->BTR |= (2 << 20);   // Set CAN_BTR_TS2 using left shift
	// Setting the number of time quanta for Time segment 1 (TS1 = 3-1)
	CAN1->BTR &= ~(15 << 16); // Clear bits 19, 18, 17, and 16
	CAN1->BTR |= (2 << 16);   // Set CAN_BTR_TS1 using left shift
	//Setting the Baud rate Pre-scalar for CAN1
	// BRP[9:0] = 16-1
	CAN1->BTR |= ((16-1)<<0);

	//Leave Initialization Mode.
	CAN1->MCR &= ~(1 << 0);
	while((CAN1->MSR) & (1 << 0))
	{}

	CAN1->MCR &= ~(1 << 1);
	while (CAN1->MSR & (1<<1)){}

	CAN1->sTxMailBox[0].TIR = 0;

	CAN1->sTxMailBox[0].TIR |= (0X245 << 21);
	CAN1->sTxMailBox[0].TDHR = 0;
	// Setting Data Length to 1 Byte.
	CAN1->sTxMailBox[0].TDTR = 1;

	//Enter Filter Initialization mode to configure the filters
	CAN1->FMR |= (1 << 0);
	// Configuring the Number of Filters Reserved for CAN1
		// and also the start bank for CAN2
	CAN1->FMR |= 14<<8;
	// Select the single 32-bit scale configuration
	CAN1->FS1R |= (1 << 13);
	// Set the receive ID
	CAN1->sFilterRegister[13].FR1 = 0x245<<21;
	// Select Identifier List mode
	CAN1->FM1R |= (1 << 13);  // Set CAN_FM1R_FBM13
	// Activating filter 13
	CAN1->FA1R |= (1 << 13);  // Set CAN_FA1R_FACT13
	// Exit filter Initialization Mode
	CAN1->FMR &= ~(1 << 0);  // Clear CAN_FMR_FINIT


}
void CAN1_Tx(uint8_t tr){
	CAN1->sTxMailBox[0].TDLR = tr;
	CAN1->sTxMailBox[0].TIR |= 1;

}
uint8_t CAN1_Rx(void){
	while(!(CAN1->RF0R & 3))
	{}
	uint8_t RxD = (CAN1->sFIFOMailBox[0].RDLR) & 0xFF;
	rec = RxD;
	CAN1->RF0R |= 1<<5;
	return RxD;

}
int main(void)
{
	GPIO_Init();
	CAN1_Init();
	while(1){
		CAN1_Tx(key);
		rec = CAN1_Rx();
	}

}
